#!/usr/bin/python
import subprocess
import os
import matplotlib.pyplot as plt
import numpy as np
import random
from scipy.optimize	import curve_fit 

# compile *.cpp files
def Compile():
	os.system("g++ ./multi-network/*.cpp -o ./multi-network/two-network-system.out")
	os.system("g++ ./lfp/*.cpp -o ./lfp/calculate-lfp.out")
	os.system("g++ ./tdmi/*.cpp -o ./tdmi/calculate-tdmi.out")

def MakeTitle(saving_filename):
	# split filename into subunit and reassumble them into acceptable title string;
	# sub_unit[0] = 'tdmi'
	# sub_unit[1] = index of neuron
	# sub_unit[2] = connecting order
	# sub_unit[3] = time range
	# sub_unit[4] = str labels of classification
	# sub_unit[5] = expected occupancy for historgram in mutual information calculation
	# sub_unit[6] = timing step for MI
	# sub_unit[7] = maximum negative time delay
	# sub_unit[8] = maximum positive time delay
	sub_unit = saving_filename.split('-')
	title = sub_unit[0].upper()
	title += ' #' + sub_unit[1]
	if sub_unit[2] == '1':
		title += ' $1^{st}$ '
	elif sub_unit[2] == '2':
		title += ' $2^{nd}$ '
	sub_sub_unit = sub_unit[3].split('_')
	title += sub_sub_unit[0] + '~' + sub_sub_unit[1] + ' ms '
	title += sub_unit[4] + '\n'
	title += 'expected occupancy = ' + sub_unit[5]
	sub_sub_unit = sub_unit[6].split('_')
	title += ' dt = ' + sub_sub_unit[0] + '.' + sub_sub_unit[1] + ' ms'
	title += ' NTD = ' + sub_unit[7]
	title += ' PTD = ' + sub_unit[8]
	return title

def DivideNeuronalFunction(neuron_types, neuron_list):
	counter = 0
	for i in neuron_list:
		if neuron_types[i] == 1:
			counter += 1 
	neuron_numbers = [counter, len(neuron_list) - counter]
	return neuron_numbers

# Create text in TDMI plot, including type of target neuron and the number of neuron it connected as well as their type;
def CreateText(loading_dir, neuron_index, order, classification, num):
	# loading files;
	pre_net_types = np.genfromtxt(loading_dir + 'preNeuron.txt', dtype = int, usecols = 0)
	post_net_types = np.genfromtxt(loading_dir + 'postNeuron.txt', dtype = int, usecols = 0)
	con_mat = np.genfromtxt(loading_dir + 'conMat.txt', dtype = int)
	# create text variable
	text = '#' + str(neuron_index) + ' neuron '
	if pre_net_types[neuron_index] == 1:
		text += 'is excitatory\n'
	else:
		text += 'is inhibitory\n'
	# consider the order of connection
	neuron_list_1 = [i for i in range(np.size(con_mat[neuron_index, :])) if con_mat[neuron_index, i] == 1]
	if order == 1:
		neuron_list_all = neuron_list_1
	else:
		neuron_list_2 = []
		for ind in neuron_list_1:
			neuron_list_2 += [j for j in range(np.size(con_mat[neuron_index, :])) if con_mat[ind, j] == 1]
		del ind
		neuron_list_2 = np.unique(neuron_list_2)
		neuron_list_all = np.setdiff1d(neuron_list_2, neuron_list_1)
	# consider the classification of connection
	if classification == 'exc':
		neuron_list = [ind for ind in neuron_list_all if post_net_types[ind] == 1]
	elif classification == 'inh':
		neuron_list = [ind for ind in neuron_list_all if post_net_types[ind] == 0]
	else:
		neuron_list = neuron_list_all
	# select num neurons from neuron pool above
	if np.size(neuron_list) > num and num > 0:
		neuron_list = random.sample(neuron_list, num)
	else:
		pass	

	text += 'LFP is generated by ' + str(np.size(neuron_list)) + ' neurons\n'
	# classify neuronal type of all this neurons
	neuron_numbers = DivideNeuronalFunction(post_net_types, neuron_list = neuron_list)
	text += 'including ' + str(neuron_numbers[0]) + ' excitatroy and ' + str(neuron_numbers[1]) + ' inhibitory neurons'
	return text

def PlotTdmi(saving_filename, figure_text):
	data_ordered = np.loadtxt("./tdmi/file-dat/tdmi_ordered.dat")
	data_rand = np.loadtxt("./tdmi/file-dat/tdmi_rand.dat")
	# basic plot
	fig = plt.figure(0, figsize=(10,8), dpi=60)
	plt.plot(data_ordered[:,0], data_ordered[:,1], label = "tdmi-original")
	plt.plot(data_rand[:,0], data_rand[:,1], label = "tdmi-swapped")
	# setting axis range;
	x_max = np.max(data_ordered[:,0])
	x_min = np.min(data_ordered[:,0])
	if np.max(data_ordered[:,1]) > np.max(data_rand[:,1]):
		y_max = np.max(data_ordered[:,1])
	else:
		y_max = np.max(data_rand[:,1])
	if np.min(data_ordered[:,1] < np.min(data_rand[:,1])):
		y_min = np.min(data_ordered[:,1])
	else:
		y_min = np.min(data_rand[:,1])
	abs_diff = y_max - y_min;
	y_min -= abs_diff * 0.1
	y_max += abs_diff * 0.1
	plt.axis([x_min, x_max, y_min, y_max])
	# setting labels and title
	plt.xlabel("Time-delay(ms)")
	plt.ylabel("Mutual Information(bits)")
	title = MakeTitle(saving_filename = saving_filename)
	# title = saving_filename
	plt.title(title)
	plt.legend()
	plt.grid(True)
	# add text
	x_text_pos = (x_max - x_min) * 0.05 + x_min
	y_text_pos = (y_max - y_min) * 0.9 + y_min
	plt.text(x_text_pos, y_text_pos, figure_text, weight = 'light')
	saving_dir = "./tdmi/figure-eps/"
	plt.savefig(saving_dir + saving_filename + '.eps')
	plt.close(0)
	del data_rand
	del data_ordered

def exp_template(x, a, b, c):
	return a*np.exp(-b * x) + c

# this program aims to analyze multiple tdmi signal from multiple trials;
def tdmi_parameters():
	# load signals
	signal_order = np.loadtxt("./tdmi/file-dat/tdmi_ordered.dat")
	signal_rand =  np.loadtxt("./tdmi/file-dat/tdmi_rand.dat")
	# calculate noise level
	noise_mean = np.mean(signal_rand[:,1])
	noise_std = np.std(signal_rand[:,1])
	# allocate maximum mutual information signal
	signal_max_ind = np.argmax(signal_order[:,1])
	signal_max = signal_order[signal_max_ind,1]
	signal_max_time = signal_order[signal_max_ind,0]

	# calculate the signal-noise ratio in TDMI data;
	sn_ratio = signal_max / noise_mean
	# find the duriation of sufficient signal
	#if type(signal_max_ind) == int:
	ind = signal_max_ind
	while signal_order[ind, 1] >= noise_mean + noise_std:
		ind -= 1
		if ind == 0:
			break
	signal_front_ind = ind
	ind = signal_max_ind
	while signal_order[ind, 1] >= noise_mean + noise_std:
		ind += 1
		if ind == len(signal_order): 
			break
	signal_back_ind = ind
	# Judge whether fit or not
	if  signal_back_ind - signal_max_ind > 3:
		try:
			popt, pcov = curve_fit(exp_template, signal_order[signal_max_ind:signal_back_ind, 0], signal_order[signal_max_ind:signal_back_ind, 1], p0 = (1, 1, 0))
		except RuntimeError:
			popt = [0, 0, 0]
		# decayed time constant
		if popt[1] == 0:
			decay_tau = 0
		else:
			decay_tau = 1 / popt[1]
	else:
		signal_max_time = -1
		decay_tau = -1
	return sn_ratio, signal_max_time, decay_tau

def pre_neuron_analysis(loading_dir, index, tmax):
	# loading_dir: directory that neuronal data locate;
	# index: index of pre-network neuron;
	# tmax: maximum simulating time, unit in second;

	# load raster data;
	data_raster = np.genfromtxt(loading_dir + "rasterPre.txt", skip_header =  index, skip_footer =  199 - index)
	mean_rate = (len(data_raster) - 1)*1.0 / tmax

	# # loading membrane potential;
	# data_potential = np.genfromtxt(loading_dir + "preV.txt", usecols = (index,))
	# freq = np.fft.fft(data_potential)
	# freq = np.fft.fftshift(freq)
	# plt.semilogy(freq[np.floor(len(freq)/ 2):len(freq)])
	# plt.show()
	return mean_rate

def SaveInfo(loading_dir, neuron_index, classification):
	"""
	Output format:
	info[0] = neuronal index
	info[1] = neuronal type
	info[2] = mean firing rate
	info[3] = number of neuron connected
	info[4] = number of excitatory connected neurons
	info[5] = number of inhibitory connected neurons
	info[6] = signal noise ratio
	info[7] = time point for maximum MI
	info[8] = time constant for tdmi decay
	"""
	info = np.zeros(9)
	info[0] = neuron_index
	pre_net_types = np.genfromtxt(loading_dir + 'preNeuron.txt', dtype = int, usecols = 0)
	info[1] = pre_net_types[neuron_index]
	info[2] = pre_neuron_analysis(loading_dir, neuron_index, 10)
	conMat = np.genfromtxt(loading_dir + 'conMat.txt', dtype = int)
	post_net_types = np.genfromtxt(loading_dir + 'postNeuron.txt', dtype = int, usecols = 0)
	connected_neurons = [ind for ind in range(0, 200) if conMat[neuron_index, ind] == 1]

	if classification == 'all':
		pass
	else:
		connected_neurons_copy = connected_neurons
		if classification == 'exc':
			connected_neurons = [ind for ind in connected_neurons_copy if post_net_types[ind] == 1]
		elif classification == 'inh':
			connected_neurons = [ind for ind in connected_neurons_copy if post_net_types[ind] == 0]
	info[3] = len(connected_neurons)
	neuron_numbers = DivideNeuronalFunction(post_net_types, connected_neurons)
	info[4] = neuron_numbers[0]
	info[5] = neuron_numbers[1]
	signal_noise_ratio, signal_max_time, time_const = tdmi_parameters()
	info[6] = signal_noise_ratio
	info[7] = signal_max_time 
	info[8] = time_const
	return info


def main():
	# Update to newest code version;
	compile_updated = True;
	if compile_updated == False:
		Compile()
	# setting preliminary parameters
	loading_dir = "/media/kyle/Drive/ResearchData/Apr05/seed200/"
	total_neuron_number = 200
	simulation_accomplish = False
	time_lb = 1000
	time_ub = 10000
	expected_occupancy = 50
	negative_time_delay = 60
	positive_time_delay = 100
	
	# Generating neruonal data based on settings above;
	if simulation_accomplish == False:
		subprocess.call(["./multi-network/two-network-system.out", loading_dir])
	# Setting loops for local field potentials;
	# all_neuron = range(0, 100)
	# target_neuron_indice_list = random.sample(all_neuron, 1)
	target_neuron_indice_list = range(0, total_neuron_number)
	order_options = [1]
	classification_options = ['all']
	# number of neurons in given classification;
	#num_list = range(0, 8)
	num = 0
	# Setting loops for time-delayed mutual information;
	timing_step_list = [0.25]
	# preparing storage for data;

	loop_counter = 0
	# Start loops
	for ind in target_neuron_indice_list:
		for order in order_options:
			for classification in classification_options:
				# for num in num_list:
				subprocess.call(["./lfp/calculate-lfp.out", loading_dir, str(int(ind)), str(order), str(time_lb), str(time_ub), classification, str(num), str(total_neuron_number)])
				for dt in timing_step_list:
					subprocess.call(['./tdmi/calculate-tdmi.out', str(expected_occupancy), str(dt), str(negative_time_delay), str(positive_time_delay)])
					
					# # create a saving filename

					# saving_filename = 'tdmi-' + str(int(ind)) + '-' + str(order) + '-' + str(time_lb) + '_' + str(time_ub) + '-' + classification + '-' + str(expected_occupancy) + '-';
					# str_dt = str(dt).split('.')
					# saving_filename += str_dt[0] + '_' + str_dt[1] + '-' + str(negative_time_delay) + '-' + str(positive_time_delay)
					# # saving_filename = 'tdmi-20-' + str(num)
					# # create figure_text
					# figure_text = CreateText(loading_dir = loading_dir, neuron_index = int(ind), order = order, classification = classification, num = num)
					# print figure_text
					# PlotTdmi(saving_filename = saving_filename, figure_text = figure_text)

					loop_counter += 1
					if loop_counter == 1:
						data_2d = SaveInfo(loading_dir = loading_dir, neuron_index = ind, classification = classification)
					elif loop_counter == 2:
						data_2d = [data_2d, SaveInfo(loading_dir = loading_dir, neuron_index = ind, classification = classification)]
					else:
						data_2d = data_2d + [SaveInfo(loading_dir = loading_dir, neuron_index = ind, classification = classification)]
					print '=================================================='
	data_2d = np.array(data_2d)
	# print data_2d
	np.savetxt(loading_dir + "pre-net-data.txt", data_2d, delimiter = '\t', newline = '\n', fmt = '%.4f')


main()
