//******************************
//	Copyright: Kyle Chen
//	Author: Kyle Chen
//	Description: Define class Neuron, structure Spike and NeuronState;
//	Date: 2017-03-08 11:08:45
//******************************
#ifndef _NEURON_H_
#define _NEURON_H_

#include <string>
#include <vector>
#include <iostream>

using namespace std;

struct Spike {
	bool function; // function of spike: true for excitation, false for inhibition;
	double t; // Exact spiking time;
	bool mode; // mode of spike: true for feedforward spike, false for neuronal input spike;
};

struct NeuronalState {
	bool type; // neuronal type: true for excitatory, false for inhibitory;
	int index; // index of neuron in loop lattice;
	double membrane_potential_; // membrane potential;
	double ge; // excitatory conductance;
	double gi; // inhibitory conductance;
	double remaining_refractory_time;
};

// Class Neuron: Based on integrate and fire neuron model;
class Neuron {
	private:
		// PARAMETERS:
		bool type_;						// neuronal type: true for excitatory, false for inhibitory;
		double tau_e_ = 2.0;	// (ms) time const for excitatory conductance;
		double tau_i_ = 5.0;	// (ms) time const for inhibitory conductance;
		double g_m_ = 5e-2;		// (1/ms) normalized membrane conductance;
		double tau_ = 2.0;		// (ms) refractory Period;
		double resting_potential_ = 0.0;
		double threshold_potential_ = 1.0;
		double excitatory_reversal_potential_ = 14.0 / 3.0;
		double inhibitory_reversal_potential_ = -2.0 / 3.0;
		double feedforward_excitatory_intensity_;
		double feedforward_inhibitory_intensity_;
		double pyramidal_synaptic_intensity_;
		double interneuronal_synaptic_intensity_;

		// DATA:

		size_t cycle_;	// number of cycle that neuron processed;
		vector<double> spike_train_; // Exact time nodes that neuron fires.
		bool driven_type_; // True for external Poisson driven, false for internal Poisson driven;
		double excitatory_poisson_rate_;
		double inhibitory_poisson_rate_;
		// Synaptic input received by neuron, including feedforward and interneuronal spikes;
		vector<Spike> synaptic_driven_;  
		// record last Poisson spike time generated by Poisson generator;
		double latest_excitatory_poisson_time_; 
		double latest_inhibitory_poisson_time_; 

		// excitatory and inhibitory conductance; evolve precisely with the given expression;
		const int dym_n_ = 4;
		const int v_idx_ = 0;
		const int gE_idx_ = 1;
		const int gI_idx_ = 2;
		const int tr_idx_ = 3;
		// index of remaining refractory period time. if negative, remaining refractory period equals to zero;

		// FUNCTIONS:

		// Generate Poisson sequence within each time step; autosort after generatation if synaptic delay is nonzero;
		// function: function of Poisson spike, true for exc, false for inh;
		// tmax: maximum time of Poisson sequence;
		// outSet: whether print spike times of each spiking events, true for print, false for not;
		// return: none;
		void GenerateInternalPoisson(bool function, double tmax, bool outSet);

		// Input external Poisson sequence within each time step, autosort after generatation if synaptic delay is nonzero;
		// function: function of Poisson spike, true for exc, false for inh;
		// tmax: maximum time of Poisson sequence;
		// x: container of external inputing spikes;
		// return: none;
		void InputExternalPoisson(bool function, double tmax, vector<double> & x);

		//	Update excitatory conductance, after receiving a spiking input:
		//	mode description: true for feedforward input, false for interneuronal input;
		//	function description: functional type of inputing signal, true for excitation, false for inhibition;
		//	return: none;
		void UpdateG(double *dym_val, bool mode, bool function);

		// ODE govern the dynamic of IF neuron;
		// voltage: membrane potential V;
		// return: dV/dt, the derivative of V;
		double GetDv(double *dym_val);
		
		//	Update the conductance and membrane potential for t = [t_n, t_n + dt];
		//	Description: 4th-order Runge Kutta integration scheme is applied;
		//	*voltage: pointer of voltage, updated after excecution;
		//	dt: size of time step, unit ms;
		//	return: derivative of membrane potential at t = t(n);
		double UpdatePotential(double *dym_val, double dt);

		//	Find the exact firing time for t = [t_n, t_n + dt] with cubic Hermite interpolation;
		//	k1: the derivative of V at t = t_n;
		//	voltage: the membrane potential at t = t_n + dt;
		//	dt: size of time step, unit millisecond;
		//	return: the exact spike time;
		double FindExactSpike(double v1, double dv1, double *dym_val, double dt);

		//	Off refractory period operation; Update conductance;
		//	Description: calculate the first non-zero membrane potential after refractory period;
		//	*voltage: point of voltage at t = t_n + dt;
		//	dt: size of time step, unit ms;
		//	Return: V at t = t_n + dt;
		double OffRefractoryPeriod(double *dym_val, double dt);

		//	Prime operation for updating neuronal state within single time step dt;
		//	Description: operation to update neuronal state in primary level, including updating conductances, membrane potential and checking spiking events; ONE synaptic input most which arrives at the begining of time step;
		//	dym_val: array of dynamic variables;
		//	is_fire: true for the presence of a synaptic input at the begining of time step; false for not;
		//  mode: mode for the synaptic input;
		//  function: function for synaptic input;
		//  time: the begining of the time step, used to record the spiking time;
		//  dt: size of time step, unit ms;
		//  temp_switch: true for update membrane_potential_temp_, conductance and record new spikes; false for similar operation but do not record new spikes;
		//	return:
		//    for non-temp operation, return -1;
		//    for temp ones, if fires, return spike time, else return -1;
		double PrimelyUpdateState(double *dym_val, bool is_fire, bool mode, bool function, double t, double dt, bool temp_switch);

		//	Update conductance of fired neuron within single time step dt; it has the same structure level as the PrimelyUpdateState(bool, bool, bool, double, double, bool);
		//	Description: operation to update neuronal state in primary level, ONE synaptic input most which arrives at the begining of time step;
		//  is_fire: true for the presence of a synaptic input at the begining of time step; false for not;
		//  mode: mode for the synaptic input;
		//  function: function for synaptic input;
		//  dt: size of time step, unit millisecond;
		//	return: none;
		void UpdateConductanceOfFiredNeuron(double *dym_val, bool is_fire, bool mode, bool function, double dt);

	public:
		// Initialization of parameters in Neuron;
		Neuron(double *&dym_val) {
			type_ = true;
			feedforward_excitatory_intensity_ = 5e-3;
			feedforward_inhibitory_intensity_ = 5e-3;
			pyramidal_synaptic_intensity_ = 5e-3;
			interneuronal_synaptic_intensity_ = 5e-3;
			driven_type_ = false;
			excitatory_poisson_rate_ = 1e-18;
			inhibitory_poisson_rate_ = 1e-18;
			latest_excitatory_poisson_time_ = 0.0;
			latest_inhibitory_poisson_time_ = 0.0;
			cycle_ = 0;
			dym_val = new double[dym_n_];
			dym_val[v_idx_] = 0.0;
			dym_val[gE_idx_] = 0.0;
			dym_val[gI_idx_] = 0.0;
			dym_val[tr_idx_] = -1.0;
		}

		// INPUTS:
		// Set neuronal type: true for excitatory; false for inhibitory;
		void SetNeuronType(bool x) { type_ = x; }

		//	Set driving type: true for external, false for internal;
		void SetDrivingType(bool x) { driven_type_ = x; }

		void SetSynapticStrength(bool function, double S);

		void SetFeedforwardStrength(bool function, double F);

		//	Set Poisson Rate: homogeneous Poisson driving rate of internal driving type;
		//	BOOL function: type of Poisson drive, true for excitatory, false for inhibitory;
		void SetPoissonRate(bool function, double rate);

		// Define a 'neuron_file' type to store neuronal condition;
		// A ROW VECTOR:
		//	0: neuronal type;
		//	1: neuronal index;
		//	2: membrane potential;
		//	3: excitatory conductivity;
		//	4: inhibitory conductivity;
		//	5: remaining refractory period;
		void LoadNeuronalState(NeuronalState & data);

		//	Input synaptic inputs, either feedforward or interneuronal ones, autosort after insertion;
		void InSpike(Spike x);

		// Reset neuron into the condition at zero time point;
		void Reset(double *dym_val);

		// DYNAMICS:

		// 	Update neuronal state:
		//	Description: update neuron within single time step, including its membrane potential, conductances and counter of refractory period;
		//	DOUBLE t: time point of the begining of the time step;
		//	DOUBLE dt: size of time step;
		//	VECTOR<DOUBLE> inPE: external excitatory Poisson sequence;
		//	VECTOR<DOUBLE> inPI: external inhibitory Poisson sequence;
		//	Return: membrane potential at t = t + dt;
		double UpdateNeuronalState(double *dym_val, double t, double dt);
		double UpdateNeuronalState(double *dym_val, double t, double dt, vector<double> & inPE, vector<double> & inPI);
		double UpdateNeuronalState(double *dym_val, double * dym_val_new, double tmax);
		//double UpdateNeuronalState(double t, double dt, vector<double> & inPE, vector<double> & inPI);

		//	Temporally update neuronal state;
		//	Description: update neuron state to check whether it would fire, while don't change its stored parameters, including membrane potential, conductances and counter of refractory period;
		//	dym_val: array of dynamic variables at t_n;
		//	dym_val_new: array of dynamic variables at t_n+1;
		//	t: time point of the begining of the time step;
		//	dt: size of time step;
		//	inPE: external excitatory Poisson sequence;
		//	inPI: external inhibitory Poisson sequence;
		//	Return: if fire, return the spiking time;
		//					if not, return -1;
		double TemporallyUpdateNeuronalState(double *dym_val, double *dym_val_new, double t, double dt, vector<double> & inPE, vector<double> & inPI);

		void UpdateConductance(double *dym_val, double t, double dt);
		//	Fire: update neuronal state for neurons which fire at t = t + dt;
		void Fire(double *dym_val, double t, double dt);
		void Fire(double spike_time);

		// OUTPUTS:

		// Print cycle_:
		size_t GetCycle() {
			cout << cycle_;
			return cycle_;
		}
		//	Get last spike: return the time point of latest spiking events;
		double GetLastSpike() { return spike_train_.back(); }

		//	Get potential: return the current value of membrane potential;
		double GetPotential(double *dym_val) { return dym_val[v_idx_]; }

		//	Get neuronal type: true for excitatory, false for inhibitory;
		bool GetNeuronalType() { return type_; }

		//	Output spike train
		void OutSpikeTrain(vector<double> & spikes);

		//  Output Spikes before t;
		void GetNewSpikes(double t, vector<Spike> &x);

		// Total membrane current;
		double OutTotalCurrent(double *dym_val);

		// Leaky current;
		double OutLeakyCurrent(double *dym_val);

		// Excitatory or inhibitory membrane current;
		double OutSynapticCurrent(double *dym_val, bool type);

		// True return excitatory conductance, false return inhibitory conductance;
		double GetConductance(double *dym_val, bool x);

		//Save corrent neuronal States:
		//Define a 'neuronFile' type to store neuronal condition;
		//A ROW VECTOR:
		//	0: neuronal type;
		//	1: neuronal index;
		//	2: membrane potential;
		//	3: excitatory conductivity;
		//	4: inhibitory conductivity;
		//	5: remaining refractory period;
		void Save(NeuronalState & vals);
};

//	external Poisson generator:
//	rate: mean Poisson firing rate;
//	tmax: maximum timel'
//	seed: random seed;
//	list: memory storage for Poisson squence;
void GenerateExternalPoissonSequence(double rate, double tmax, int seed, vector<double> & list);

#endif 	// _NEURON_H_
