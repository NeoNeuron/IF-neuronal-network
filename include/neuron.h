//******************************
//	Copyright: Kyle Chen
//	Author: Kyle Chen
//	Description: Define class Neuron, structure Spike and NeuronState;
//	Date: 2017-03-08 11:08:45
//******************************
#ifndef _NEURON_H_
#define _NEURON_H_

#include<string>
#include<vector>

using namespace std;

struct Spike {
	bool function; // function of spike: true for excitation, false for inhibition;
	double t; // Exact spiking time;
	bool mode; // mode of spike: true for feedforward spike, false for neuronal input spike;
};

struct NeuronalState {
	bool type; // neuronal type: true for excitatory, false for inhibitory;
	int index; // index of neuron in loop lattice;
	double membrane_potential_; // membrane potential;
	double ge; // excitatory conductance;
	double gi; // inhibitory conductance;
	double remaining_refractory_time;
};

// Class Neuron: Based on integrate and fire neuron model;
class Neuron {
private:
	// PARAMETERS:
	bool type_;						// neuronal type: true for excitatory, false for inhibitory;
	int index_;						// index of neuron in loop lattice;
	double tau_e_ = 2.0;	// (ms) time constant for excitatory conductance;
	double tau_i_ = 5.0;	// (ms) time constant for inhibitory conductance;
	double g_m_ = 0.05;		// (1/ms) normalized membrane conductance;
	double tau_ = 2.0;		// (ms) refractory Period;
	double resting_potential_ = 0.0;
	double threshold_potential_ = 1.0;
	double excitatory_reversal_potential_ = 14.0 / 3.0;
	double inhibitory_reversal_potential_ = -2.0 / 3.0;
	double feedforward_excitatory_intensity_;
	double feedforward_inhibitory_intensity_;
	double pyramidal_synaptic_intensity_;
	double interneuronal_synaptic_intensity_;

	// DATA:

	vector<double> spike_train_; // Exact time nodes that neuron fires.
	bool driven_type_; // True for external Poisson driven, false for internal Poisson driven;
	double excitatory_poisson_rate_;
	double inhibitory_poisson_rate_;
	// Synaptic input received by neuron, including feedforward and interneuronal spikes;
	vector<Spike> synaptic_driven_;  
	// record last Poisson spike time generated by Poisson generator;
	double latest_excitatory_poisson_time_; 
	double latest_inhibitory_poisson_time_; 

	// excitatory and inhibitory conductance; evolve precisely with the given expression;
	double dy_val_[3];
	int v_idx_ = 0;
	int gE_idx_ = 1;
	int gI_idx_ = 2;
	double remaining_refractory_period_; // if negative, remaining refractory period equals to zero;

	// FUNCTIONS:

	// Generate Poisson sequence within each time step; autosort after generatation if synaptic delay is nonzero;
	// function: function of Poisson spike, true for exc, false for inh;
	// tmax: maximum time of Poisson sequence;
	// outSet: whether print spike times of each spiking events, true for print, false for not;
	// return: none;
	void GenerateInternalPoisson(bool function, double tmax, bool outSet);

	// Input external Poisson sequence within each time step, autosort after generatation if synaptic delay is nonzero;
	// function: function of Poisson spike, true for exc, false for inh;
	// tmax: maximum time of Poisson sequence;
	// x: container of external inputing spikes;
	// return: none;
	void InputExternalPoisson(bool function, double tmax, vector<double> & x);

	//	Update excitatory conductance, after receiving a spiking input:
	//	mode description: true for feedforward input, false for interneuronal input;
	//	function description: functional type of inputing signal, true for excitation, false for inhibition;
	//	return: none;
	void UpdateG(double *dy_val_, bool mode, bool function);

	// ODE govern the dynamic of IF neuron;
	// voltage: membrane potential V;
	// return: dV/dt, the derivative of V;
	double GetDv(double *dy_val_);
	
	//	Update the conductance and membrane potential for t = [t_n, t_n + dt];
	//	Description: 4th-order Runge Kutta integration scheme is applied;
	//	*voltage: pointer of voltage, updated after excecution;
	//	dt: size of time step, unit ms;
	//	return: derivative of membrane potential at t = t(n);
	double UpdatePotential(double *voltage, double dt);

	//	Find the exact firing time for t = [t_n, t_n + dt] with cubic Hermite interpolation;
	//	k1: the derivative of V at t = t_n;
	//	voltage: the membrane potential at t = t_n + dt;
	//	dt: size of time step, unit millisecond;
	//	return: the exact spike time;
	double FindExactSpike(double v1, double dv1, double *dy_val_, double dt);

	//	Off refractory period operation; Update conductance;
	//	Description: calculate the first non-zero membrane potential after refractory period;
	//	*voltage: point of voltage at t = t_n + dt;
	//	dt: size of time step, unit ms;
	//	Return: V at t = t_n + dt;
	double OffRefractoryPeriod(double *dy_val_, double dt);

	//	Prime operation for updating neuronal state within single time step dt;
	//	Description: operation to update neuronal state in primary level, including updating conductances, membrane potential and checking spiking events; ONE synaptic input most which arrives at the begining of time step;
  //	is_fire: true for the presence of a synaptic input at the begining of time step; false for not;
  //  mode: mode for the synaptic input;
  //  function: function for synaptic input;
  //  time: the begining of the time step, used to record the spiking time;
  //  dt: size of time step, unit ms;
	//  temp_switch: true for update membrane_potential_temp_, conductance and record new spikes; false for similar operation but do not record new spikes;
  //	return:
  //    for non-temp operation, return -1;
  //    for temp operation, if fires, return spiking time, else return -1;
	double PrimelyUpdateState(double *dy_val_, bool is_fire, bool mode, bool function, double t, double dt, bool temp_switch);

  //	Update conductance of fired neuron within single time step dt; it has the same structure level as the PrimelyUpdateState(bool, bool, bool, double, double, bool);
  //	Description: operation to update neuronal state in primary level, ONE synaptic input most which arrives at the begining of time step;
  //  is_fire: true for the presence of a synaptic input at the begining of time step; false for not;
  //  mode: mode for the synaptic input;
  //  function: function for synaptic input;
  //  dt: size of time step, unit millisecond;
  //	return: none;
	void UpdateConductanceOfFiredNeuron(double *dy_val_, bool is_fire, bool mode, bool function, double dt);

public:
	// Auto initialization of parameters in Neuron;
	Neuron() {
		type_ = true;
		index_ = -1;
		feedforward_excitatory_intensity_ = 5.0e-3;
		feedforward_inhibitory_intensity_ = 5.0e-3;
		pyramidal_synaptic_intensity_ = 5.0e-3;
		interneuronal_synaptic_intensity_ = 5.0e-3;
		driven_type_ = false;
		excitatory_poisson_rate_ = 1.0e-20;
		inhibitory_poisson_rate_ = 1.0e-20;
		latest_excitatory_poisson_time_ = 0.0;
		latest_inhibitory_poisson_time_ = 0.0;
		for (int i = 0; i < 3; i ++) dy_val_[i] = 0.0;
		remaining_refractory_period_ = -1.0;
	}

	// INPUTS:

	// Set neuronal type: true for excitatory; false for inhibitory;
	void SetNeuronType(bool x) { type_ = x; }

	//	Set neuronal index: indices of neurons in 1-D loop lattice, starting from 0 to maximum number - 1;
	void SetNeuronIndex(int x) { index_ = x; }

	//	Set driving type: true for external, false for internal;
	void SetDrivingType(bool x) { driven_type_ = x; }

	void SetSynapticStrength(bool function, double S);

	void SetFeedforwardStrength(bool function, double F);

	//	Set Poisson Rate: homogeneous Poisson driving rate of internal driving type;
	//	BOOL function: type of Poisson drive, true for excitatory, false for inhibitory;
	void SetPoissonRate(bool function, double rate);

	// Define a 'neuron_file' type to store neuronal condition;
	// A ROW VECTOR:
	//	0: neuronal type;
	//	1: neuronal index;
	//	2: membrane potential;
	//	3: excitatory conductivity;
	//	4: inhibitory conductivity;
	//	5: remaining refractory period;
	void LoadNeuronalState(NeuronalState & data);

	//	Input synaptic inputs, either feedforward or interneuronal ones, autosort after insertion;
	void InSpike(Spike x);

	// Reset neuron into the condition at zero time point;
	void Reset();

	// DYNAMICS:

	// 	Update neuronal state:
	//	Description: update neuron within single time step, including its membrane potential, conductances and counter of refractory period;
	//	DOUBLE t: time point of the begining of the time step;
	//	DOUBLE dt: size of time step;
	//	VECTOR<DOUBLE> inPE: external excitatory Poisson sequence;
	//	VECTOR<DOUBLE> inPI: external inhibitory Poisson sequence;
	//	Return: membrane potential at t = t + dt;
	double UpdateNeuronalState(double t, double dt);
	double UpdateNeuronalState(double t, double dt, vector<double> & inPE, vector<double> & inPI);

	//	Temporally update neuronal state;
	//	Description: update neuron state to check whether it would fire, while don't change its stored parameters, including membrane potential, conductances and counter of refractory period;
	//	t: time point of the begining of the time step;
	//	dt: size of time step;
	//	inPE: external excitatory Poisson sequence;
	//	inPI: external inhibitory Poisson sequence;
	//	Return: if fire, return the spiking time;
	//					if not, return -1;
	double TemporallyUpdateNeuronalState(double t, double dt, vector<double> & inPE, vector<double> & inPI);

	//	Fire: update neuronal state for neurons which fire at t = t + dt;
	void Fire(double t, double dt);

	// OUTPUTS:

	//	Get last spike: return the time point of latest spiking events;
	double GetLastSpike() { return spike_train_.back(); }

	//	Get potential: return the current value of membrane potential;
	double GetPotential() { return dy_val_[v_idx_]; }

	//	Get neuronal type: true for excitatory, false for inhibitory;
	bool GetNeuronalType() { return type_; }

	int GetNeuronIndex() { return index_; }

	//	Output spike train
	void OutSpikeTrain(vector<double> & spikes);

  //  Output Spikes before t;
	void GetNewSpikes(double t, vector<Spike> &x);

	// Total membrane current;
	double OutTotalCurrent();

	// Leaky current;
	double OutLeakyCurrent();

	// Excitatory or inhibitory membrane current;
	double OutSynapticCurrent(bool type);

	// True return excitatory conductance, false return inhibitory conductance;
	double GetConductance(bool x);

	//Save corrent neuronal States:
	//Define a 'neuronFile' type to store neuronal condition;
	//A ROW VECTOR:
	//	0: neuronal type;
	//	1: neuronal index;
	//	2: membrane potential;
	//	3: excitatory conductivity;
	//	4: inhibitory conductivity;
	//	5: remaining refractory period;
	void Save(NeuronalState & vals);
};

//	external Poisson generator:
//	rate: mean Poisson firing rate;
//	tmax: maximum timel'
//	seed: random seed;
//	list: memory storage for Poisson squence;
void GenerateExternalPoissonSequence(double rate, double tmax, int seed, vector<double> & list);

#endif 	// _NEURON_H_
